HashiCorp Vault - это инструмент с открытым исходным кодом, который обеспечивает безопасный и надежный способ хранения и распространения секретов, таких как ключи API, токены доступа и пароли. Программное обеспечение, такое как Vault, может быть критически важным при развертывании приложений, требующих использования секретов или конфиденциальных данных.

<cut />

Согласно [недавнему исследованию](https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04B-3_Meli_paper.pdf) ученых из Университета штата Северная Каролина, более 100 000 общедоступных репозиториев GitHub содержат открытые секреты приложений непосредственно в исходном коде. Это исследование - от частных токенов API до криптографических ключей - просканировало только около 13% общедоступных репозиториев GitHub - показывает, что надлежащая защита секретов приложений является одним из наиболее часто игнорируемых методов защиты информации в программном обеспечении.

Хотя масштабы воздействия удивительны, важно отметить, что эта проблема затрагивает не только проекты с открытым исходным кодом. Даже частные репозитории исходного кода могут раскрывать секреты, если они не защищены должным образом. Возьмем, к примеру, [нарушение безопасности в Buffer Inc.](https://open.buffer.com/buffer-has-been-hacked-here-is-whats-going-on/) в 2013 году. То, что начиналось как незаконный доступ к собственному исходному коду Buffer, привело к утечке учетных данных Twitter API компании, что в конечном итоге привело к рассылке спама в учетных записях Twitter бесчисленных клиентов.

Я не собираюсь угнетать Buffer прямо сейчас. Компании взламывают каждый день, и Buffer дал первоклассный ответ. Их нефильтрованная прозрачность и [информирование об инцидентах](https://victorops.com/blog/outage-communication-practices) послужили интересным примером важности управления секретами как основного принципа информационной безопасности. Но это также поднимает вопрос о том, как лучше всего управлять секретами в растущей, масштабируемой организации.

Введение в HashiCorp Vault

Я большой поклонник HashiCorp. Их подход к [инструментам DevOps](https://victorops.com/blog/top-devops-tools), не зависящий от поставщика, предоставляет отличные портативные решения, которые абстрагируются от отдельных поставщиков облачных услуг и фокусируются на решении реальных проблем. Их инструмент управления секретами, [Vault](https://www.vaultproject.io/), не исключение.

В то время как каждый отдельный поставщик облачных услуг имеет собственное решение для управления секретами, Vault является независимым от поставщика решением, которое позволяет централизованно управлять и обеспечивать доступ к секретам приложений без учета базового механизма секретов или методов аутентификации.

Установка Vault

[Скачать Vault - Vault от HashiCorp](https://www.vaultproject.io/downloads.html)

Прежде чем мы сможем начать работу с Vault, нам сначала нужно его установить. Как и все продукты HashiCorp, Vault кроссплатформенный, с поддержкой macOS, Windows, Linux, Solaris и даже BSD. Вы даже можете запустить его на Raspberry Pi.

Запуск сервера

После установки Vault нам нужно запустить наш сервер. В этой статье я буду работать только с сервером разработки Vault. Однако важно отметить, что сервер разработки **невероятно небезопасен** и хранит все данные **в памяти**, а это означает, что при его перезапуске все будет потеряно. По словам самих HashiCorp:

*Сервер разработки следует использовать для экспериментов с функциями Vault, такими как: различные методы аутентификации, механизмы секретов, устройства аудита и т. д.*

Чтобы запустить сервер разработки, просто запустите команду `vault server -dev` (`-dev` указывает, что мы должны запускать сервер разработки, а не рабочий сервер):

```bash
$ vault server -dev
==> Vault server configuration:

     	Api Address: http://127.0.0.1:8200
             	Cgo: disabled
 	Cluster Address: https://127.0.0.1:8201
      	Listener 1: tcp (addr: "127.0.0.1:8200", cluster address: "127.0.0.1:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "disabled")
       	Log Level: info
           	Mlock: supported: false, enabled: false
         	Storage: inmem
         	Version: Vault v1.2.1

WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to seal/unseal the Vault or re-authenticate.

Unseal Key: p8MumXfy57bh2T1FxdvZSmHhxqr7aQAByPpfE4PLujk=
Root Token: s.aSQmpEYEi5MKelf5TDLPC6r9

Development mode should NOT be used in production installations!

==> Vault server started! Log data will stream in below:
```

Как видите, на экран выводится много данных, с которыми вы можете поиграть. Прежде всего следует отметить, что сервер разработки по умолчанию не запускается как демон (и в целях тестирования, никогда не должен запускаться как демон). Следовательно, если вы хотите взаимодействовать с сервером, вы должны сначала открыть второе окно терминала и экспортировать предоставленную переменную среды **VAULT_ADDR**, чтобы команда Vault хранилища знала, с каким сервером она должна взаимодействовать.

Также важно отметить значения **Unseal Key** и **Root Token**. Хотя мы коснемся того, что делать с **Root Token** в следующем разделе, понимание запечатывания / распечатывания Vault имеет решающее значение для правильного развертывания Vault в производственной среде.

Расшифровка и аутентификация

В производственной среде сервер Vault запускается в закрытом состоянии. Это означает, что Vault знает, где находятся данные, но не знает, как их расшифровать. На сервере разработки Vault по умолчанию не запечатан (**unsealed**). Однако, если вы решите запечатать его, вы получите ключ распечатки (**Unseal Key**), чтобы распечатать (**unseal**) его. Незапечатанный Vault остается в этом состоянии до тех пор, пока оно не будет повторно запечатано или сам сервер не будет перезапущен.

При первом запуске производственного сервера Vault важно его инициализировать. Этот процесс сгенерирует ключи шифрования и начальный корневой токен, и его можно будет запустить только с новыми хранилищами без каких-либо данных:

```bash
$ vault operator init

Unseal Key 1: 4jYbl2CBIv6SpkKj6Hos9iD32k5RfGkLzlosrrq/JgOm
Unseal Key 2: B05G1DRtfYckFV5BbdBvXq0wkK5HFqB9g2jcDmNfTQiS
Unseal Key 3: Arig0N9rN9ezkTRo7qTB7gsIZDaonOcc53EHo83F5chA
Unseal Key 4: 0cZE0C/gEk3YHaKjIWxhyyfs8REhqkRW/CSXTnmTilv+
Unseal Key 5: fYhZOseRgzxmJCmIqUdxEm9C3jB5Q27AowER9w4FC2Ck

Initial Root Token: s.KkNJYWF5g0pomcCLEmDdOVCW

Vault initialized with 5 key shares and a key threshold of 3. Please securely distribute the key shares printed above. When the Vault is re-sealed, restarted, or stopped, you must supply at least 3 of these keys to unseal it before it can start servicing requests.

Vault does not store the generated master key. Without at least 3 keys to reconstruct the master key, Vault will remain permanently sealed!

It is possible to generate new unseal keys, provided you have a quorum of existing unseal keys shares. See "vault operator rekey" for more information.
```

Вход в систему

Когда сервер запущен, следующее, что нам нужно сделать, это войти в него. Это можно сделать с помощью команды `vault login`, которая запросит токен аутентификации. При первоначальной настройке вы можете пройти аутентификацию с помощью Root Token (см. Выше). Однако в производственной среде базовые методы аутентификации можно изменить, чтобы обеспечить более точный контроль над тем, кто имеет доступ и почему:

```bash
$ vault login
Token (will be hidden):
Success! You are now authenticated. The token information displayed below is already stored in the token helper. You do NOT need to run "vault login" again. Future Vault requests will automatically use this token.

Key              	Value
---              	-----
token            	s.aSQmpEYEi5MKelf5TDLPC6r9
token_accessor   	MaJhao2R54EdV9fDq7sL11d4
token_duration   	∞
token_renewable  	false
token_policies   	["root"]
identity_policies	[]
policies         	["root"] 
```

Хранение секретов

В то время как Vault HashiCorp можно использовать для безопасного хранения практически любых данных, наиболее распространенным вариантом использования Vault является хранилище ключей и значений для секретов приложений. После проверки подлинности хранение секретов становится невероятно простым благодаря команде `vault kv put`:

```bash
$ vault kv put secret/foo bar=baz
Key          	Value
---          	-----
created_time 	2019-08-09T16:43:10.604124Z
deletion_time	n/a
destroyed    	false
version      	1
```

Чтобы немного разобрать приведенную выше команду и ответ, мы создали новый секрет с именем `foo` в пространстве имен `secret` со значением `bar=baz`, ответ дает нам некоторые базовые метаданные о нашем новом секрете. Хотя ключи `created_time`, `deletion_time` и `destroyed` не требуют пояснений, вам следует обратить особое внимание на ключ `version`, потому что это подразумевает, что секреты могут быть версированы.

Например, давайте посмотрим, что произойдет, если мы введем новое значение для того же секрета:

```bash
$ vault kv put secret/foo bat=ball
Key          	Value
---          	-----
created_time 	2019-08-09T16:43:32.638788Z
deletion_time	n/a
destroyed    	false
version      	2
```

Видите, как был увеличен ключ метаданных версии? Это означает, что наше исходное значение должно поддерживаться в дополнение к новым значениям, что обеспечивает отличный журнал аудита того, какие секреты были изменены и когда.

Извлечение секретов

```bash
$ vault kv list secret
Keys
----
foo
```

Хранение секретов - это только половина дела. Другая половина - извлекать эти секреты. В нашем примере выше давайте сначала посмотрим, как получить весь список секретов:

 
Как видите, хотя технически мы помещаем два секрета, отслеживается только один ключ, потому что эти два секрета на самом деле являются всего лишь двумя версиями одного секрета. Чтобы получить его, выполните команду `vault kv get` с секретным пространством имен и ключом:

```bash
$ vault kv get secret/foo
====== Metadata ======
Key          	Value
---          	-----
created_time 	2019-08-09T16:43:32.638788Z
deletion_time	n/a
destroyed    	false
version      	2

=== Data ===
Key	Value
---	-----
bat	ball
```

По умолчанию Vault будет извлекать самую последнюю версию секрета, но если мы хотим получить предыдущую версию, можно использовать директиву `-version`:

```bash
$ vault kv get -version=1 secret/foo
====== Metadata ======
Key          	Value
---          	-----
created_time 	2019-08-09T16:43:10.604124Z
deletion_time	n/a
destroyed    	false   
version      	1

=== Data ===
Key	Value
---	-----
bar	baz
```

Ценность секретов с управлением версиями невероятна, поскольку они позволяют внутренним службам привязаться к различным секретным версиям, что дает возможность постепенно развиваться, выпускать ([release](https://victorops.com/blog/keys-to-effective-release-management)) и откатывать изменения приложений, не опасаясь потери важных данных.

Удаление секретов

Несмотря на преимущества контроля секретами, нам может понадобится фактическое удаление секрета (или его версии). Это можно сделать двумя способами, в зависимости от того, насколько «удаленным» вы хотите, чтобы секрет был: удалить `delete` и уничтожить `destroy`. Чтобы проиллюстрировать это, давайте сначала рассмотрим удаление версии нашего секрета `foo`:

```bash
$ vault kv delete -versions=1 secret/foo
Success! Data deleted (if it existed) at: secret/foo
 ```

Это помечает данные как удаленные (`deleted`) и предотвращает их извлечение в обычных запросах GET, но фактически не удаляет данные:

```bash
$ vault kv get -version=1 secret/foo
====== Metadata ======
Key          	Value
---          	-----
created_time 	2019-08-09T16:43:10.604124Z
deletion_time	2019-08-09T16:45:39.664577Z
destroyed    	false
version      	1
 ```

Чтобы данные действительно были удалены без возможности восстановления, необходимо использовать команду destroy:

```bash
$ vault kv destroy -versions=1 secret/foo
Success! Data written to: secret/destroy/foo
```

Вместо того, чтобы просто пометить данные как удаленные и ограничить доступ к ним, команда destroy удалит их полностью, что сделает невозможным последующее извлечение:

```bash
$ vault kv get -version=1 secret/foo
====== Metadata ======
Key          	Value
---          	-----
created_time 	2019-08-09T16:43:10.604124Z
deletion_time	2019-08-09T16:45:39.664577Z
destroyed    	true
version      	1
```

Копаем глубже в HashiCorp Vault

Vault - сложный инструмент, и управление такими секретами - это лишь малая часть того, что можно с его помощью сделать. Хотя тонкости Vault выходят далеко за рамки этой статьи, давайте коснемся лишь нескольких других концепций, которые делают Vault таким мощным.

Secrets engines

```bash
$ vault secrets enable database
Success! Enabled the database secrets engine at: database/
```

Хранилище ключей и значений по умолчанию в Vault является примером [механизма секретов](https://www.vaultproject.io/api/secret/index.html) (в частности, механизма под названием `kv`). По своей сути алгоритм секретов - это абстрактный механизм хранения секретных данных. Это означает, что вместо механизма хранения на основе ключа-значения можно использовать более целевые механизмы хранения. Например, механизм секретов базы данных может использоваться для динамического генерирования учетных данных базы данных (`database`) на основе настроенных ролей для [MySQL и MariaDB](https://www.vaultproject.io/docs/secrets/databases/mysql-maria.html), что позволяет производить автоматическую ротацию учетных данных root или даже временные учетные данные для доступа по запросу.

Методы аутентификации

```bash
$ vault auth enable github
Success! Enabled github auth method at: github/
```

В дополнение к стандартному методу аутентификации на основе токенов Vault поддерживает ряд дополнительных [методов аутентификации](https://www.vaultproject.io/api/auth/index.html) для лучшей поддержки ваших вариантов использования. Отличным примером этого является метод проверки подлинности [GitHub](https://www.vaultproject.io/docs/auth/github.html), который можно использовать для автоматического предоставления доступа к Vault разработчикам, принадлежащим к определенной организации GitHub - и даже к определенной группе внутри организации GitHub - с использованием только токена личного доступа. Для более крупных организаций решения единого входа на уровне предприятия, такие как [LDAP](https://www.vaultproject.io/docs/auth/ldap.html) или [Okta](https://www.vaultproject.io/docs/auth/okta.html), могут использоваться для аутентификации пользователей в Vault.

Авторизация 

```bash
$ vault write auth/userpass/users/test policies="dev-readonly,logs"
```

Авторизация всегда идет рука об руку с аутентификацией. Хотя предоставить глобальный доступ с помощью GitHub или аутентификации на основе токенов несложно, это почти никогда не бывает полным решением. Благодаря [политике](https://www.vaultproject.io/docs/concepts/policies.html) Vault может быть реализован метод авторизации в стиле RBAC, предоставляющий разным пользователям и группам CRUD-подобный доступ к различным аспектам самого хранилища. В сочетании с одним из более продвинутых методов аутентификации это может стать невероятно мощным инструментом для детального контроля доступа в большой организации.

За пределами Vault

Каким бы мощным ни было Vault, настроить его правильно довольно сложно. Хотя размер и объем различных методов проверки подлинности и механизмов секретов ясно показывают, сколько вы можете сделать с Vault, может быть сложным осмыслить основы управления секретами в контексте информационной безопасности исходного кода. Благодаря впечатляюще большому количеству как официальных, так и общественных [библиотек API](https://www.vaultproject.io/api/libraries.html), получение секретов безопасным способом невероятно просто, и если вы стремитесь стать опытным пользователем Vault, собственная [учебная программа](https://learn.hashicorp.com/vault) Vault HashiCorp – отличный способ для начала изучения.

Помимо безопасности приложений и инфраструктуры, вам нужен план быстрого реагирования на инциденты. Ознакомьтесь с нашим бесплатным руководством «От реактивного к упреждающему: 6 способов трансформации вашего мониторинга и реагирования на инциденты» для создания прозрачных рабочих процессов управления инцидентами с высокой степенью совместной работы.
