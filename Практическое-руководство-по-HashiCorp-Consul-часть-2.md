Практическое руководство по HashiCorp Consul - Часть 2

Это вторая часть из 2 частей Практического руководства по HashiCorp Consul. Предыдущая часть была в первую очередь сосредоточена на понимании проблем, которые решает Consul, и на том, как он их решает. Эта часть посвящена практическому применению Consul на примере реальной жизни. Давайте начнем.

Развивая большую часть теории, рассмотренной в предыдущей части, давайте перейдем к практическому примеру Consul.

 

Что мы строим?

Мы собираемся создать веб-приложение Django, которое хранит свои постоянные данные в MongoDB. Мы поместим их в контейнер с помощью Docker. Скомпилируйте и запустите их с помощью Docker Compose.

Чтобы показать, как наше веб-приложение будет масштабироваться в этом контексте, мы собираемся запустить два экземпляра приложения Django. Кроме того, чтобы сделать это еще более интересным, мы запустим MongoDB как набор реплик с одним первичным узлом и двумя вторичными узлами.

Учитывая, что у нас есть два экземпляра приложения Django, нам понадобится способ сбалансировать нагрузку между этими двумя экземплярами, поэтому мы собираемся использовать Fabio, балансировщик нагрузки, поддерживающий Consul, для доступа к экземплярам приложения Django.

Этот пример примерно поможет нам смоделировать реальное практическое приложение.

 

Примеры узлов приложений и развернутых на них служб

 

Полный исходный код этого приложения является открытым и доступен на GitHub - pranavcode / consul-demo.

Примечание. Обсуждаемая здесь архитектура не накладывает особых ограничений на какие-либо технологии, используемые для создания уровней приложений или данных. Этот пример вполне может быть построен с использованием комбинации Ruby on Rails и Postgres, или Node.js и MongoDB, или Laravel и MySQL.

 

Какое место занимает Консул?

Мы развертываем приложение и слои данных с контейнерами Docker. Они будут построены как службы и будут общаться друг с другом по HTTP.

Таким образом, мы будем использовать Consul для Service Discovery. Это позволит серверам Django найти первичный узел MongoDB. В этом примере мы собираемся использовать Consul для разрешения служб через интерфейс Consul DNS.

Consul также поможет нам с автоматической настройкой Fabio в качестве балансировщика нагрузки для доступа к экземплярам нашего приложения Django.

Мы также используем функцию проверки работоспособности Consul, чтобы отслеживать работоспособность каждого из наших экземпляров во всей инфраструктуре.

Consul предоставляет красивый пользовательский интерфейс, как часть своего веб-интерфейса, чтобы показать все службы на одной панели. Мы будем использовать его, чтобы увидеть, как устроены наши услуги.

Давайте начнем.

 

Настройка: MongoDB, Django, Consul, Fabio и Dockerization

Мы сделаем это настолько быстро и просто, насколько это возможно, чтобы продемонстрировать вам все возможности.

 

MongoDB

Мы нацелены на настройку MongoDB в форме набора реплик MongoDB. Один первичный узел и два вторичных узла.

Первичный узел будет управлять всеми операциями записи и журналом операций, чтобы поддерживать последовательность записи и реплицировать данные между вторичными узлами. Мы также настраиваем вторичные серверы для операций чтения. Вы можете узнать больше о MongoDB Replica Set в их официальной документации.

Мы будем называть наш набор репликации consuldemo.

Мы запустим MongoDB на стандартном порту 27017 и укажем имя реплики, установленной в командной строке, с помощью параметра «- replSet».

Как вы можете прочитать из документации, MongoDB также позволяет настраивать имя набора реплик через файл конфигурации с параметром репликации, как показано ниже:

 

В нашем случае конфигурация набора репликации, которую мы будем применять на одном из узлов MongoDB, после того, как все узлы будут запущены, выглядит следующим образом:

 

Эта конфигурация будет применена к одному из предопределенных узлов, и MongoDB решит, какой узел будет основным и дополнительным.

Примечание. Мы не форсируем создание набора с предопределенными обозначениями того, кто станет основным и второстепенным, чтобы обеспечить динамизм в обнаружении услуг. Обычно узлы определяются для конкретной роли.

Мы запустим MongoDB на всех узлах с помощью следующей команды:

 

Это дает нам набор реплик MongoDB с одним первичным экземпляром и двумя вторичными экземплярами, которые работают и готовы принимать соединения.

Мы обсудим контейнеризацию службы MongoDB в последней части этой статьи.

 

Django

Мы создадим простой проект Django, представляющий приложение Blog, и контейнер его с помощью Docker.

Создание приложения Django с нуля выходит за рамки этого руководства, мы рекомендуем вам обратиться к официальной документации Django, чтобы начать работу с проектом Django. Но мы все же рассмотрим некоторые важные аспекты.

Поскольку нам нужно, чтобы наше приложение Django взаимодействовало с MongoDB, мы будем использовать коннектор MongoDB для Django ORM, Djongo. Мы настроим наши настройки Django для использования Djongo и подключения к нашей MongoDB. Djongo довольно прост в настройке.

Для локальной установки MongoDB потребуется всего две строки кода:

 

В нашем случае, поскольку нам понадобится доступ к MongoDB через другой контейнер, наша конфигурация будет выглядеть так:

 

Детали:

·    ENGINE: соединитель базы данных для использования в Django ORM.

·    NAME: Имя базы данных.

·    HOST: адрес хоста, на котором работает MongoDB.

·    PORT: какой порт ваш MongoDB прослушивает запросы.

Djongo внутренне общается с PyMongo и использует MongoClient для выполнения запросов в Mongo. Мы также можем использовать другие коннекторы MongoDB, доступные для Django, чтобы достичь этого, например, django-mongodb-engine или pymongo напрямую, в зависимости от наших потребностей.

Примечание. В настоящее время мы читаем и записываем через Django на один хост MongoDB, основной, но мы можем настроить Djongo так, чтобы он также разговаривал со второстепенными хостами для операций только для чтения. Это не входит в рамки нашего обсуждения. Вы можете обратиться к официальной документации Djongo, чтобы добиться именно этого.

Продолжая процесс создания приложения Django, нам нужно определить наши модели. Поскольку мы создаем приложение, похожее на блог, наши модели будут выглядеть следующим образом:

Мы можем запустить локальный экземпляр MongoDB и создать миграции для этих моделей. Кроме того, можем зарегистрировать эти модели в вашем администраторе Django, например:

В этом примере мы можем поиграть с CRUD-операциями модели Entry через Django Admin.

Кроме того, для реализации возможности подключения Django-MongoDB мы создадим настраиваемый вид и шаблон, который отображает информацию о настройке MongoDB и подключенном в данный момент хосте MongoDB.

Наши настройки Django выглядят так:

Наша конфигурация URL-адресов или маршрутов для приложения выглядит так:

А для проекта - URL-адреса приложений включены так:

Наш шаблон Django, «templates / home.html», выглядит так:

 

Чтобы запустить приложение, нам нужно сначала перенести базу данных, используя следующую команду:

А также собрать все статические активы в статический каталог:

Теперь запустите приложение Django с Gunicorn, HTTP-сервером WSGI, как показано ниже:

Это дает нам базовое приложение Django, подобное блогу, которое подключается к бэкэнду MongoDB.

Мы обсудим контейнеризацию этого веб-приложения Django в последней части этой статьи.

 

Consul

Мы размещаем агента Consul для каждой службы в рамках нашей установки Consul.

Агент Consul отвечает за обнаружение службы путем регистрации службы в кластере Consul, а также контролирует работоспособность каждого экземпляра службы.

 

Consul на узлах, на которых работает MongoDB Replica Set

Сначала мы обсудим настройку Consul в контексте MongoDB Replica Set, поскольку она решает интересную проблему. В любой момент времени один из экземпляров MongoDB может быть первичным или вторичным.

Агент Consul, регистрирующий и отслеживающий наш экземпляр MongoDB в наборе реплик, имеет уникальный механизм - динамическую регистрацию и отмену регистрации службы MongoDB в качестве первичного или вторичного экземпляра в зависимости от того, какой набор реплик назначил его.

Мы достигаем этого динамизма путем написания и запуска сценария оболочки после интервала, который переключает определение службы Consul для MongoDB Primary и MongoDB Secondary на Consul Agent узла экземпляра.

Определения сервисов для сервисов MongoDB хранятся в виде файлов JSON в каталоге конфигурации Consul ‘/etc/config.d’.

Определение службы для первичного экземпляра MongoDB:

 

Если вы присмотритесь, определение службы позволяет нам получить запись DNS, специфичную для MongoDB Primary, а не общий экземпляр MongoDB. Это позволяет нам отправлять записи базы данных в конкретный экземпляр MongoDB. В случае набора реплик записи поддерживаются MongoDB Primary.

Таким образом, мы можем достичь как обнаружения сервисов, так и мониторинга работоспособности для первичного экземпляра MongoDB.

Точно так же с небольшим изменением определение службы для вторичного экземпляра MongoDB выглядит следующим образом:

 

Учитывая весь этот контекст, можете ли вы представить, как мы можем динамически переключать эти определения сервисов?

Мы можем определить, является ли данный экземпляр MongoDB основным или нет, запустив команду db.isMaster () в оболочке MongoDB.

Можно оформить проверку в виде сценария оболочки следующим образом:

 

Точно так же неосновные экземпляры MongoDB также могут быть проверены на соответствие той же команде, путем проверки «вторичного» значения:

 

Примечание. Мы используем jq - легкий и гибкий процессор JSON командной строки - для обработки выходных данных команд оболочки MongoDB в кодировке JSON.

Один из способов написания сценария, выполняющего этот динамический переключатель, выглядит так:

 

Примечание. Это пример сценария. Но мы можем проявить более творческий подход и оптимизировать сценарий.

Когда мы закончим с определениями наших сервисов, мы можем запустить агент Consul на каждом узле MongoDB. Для запуска агента мы будем использовать следующую команду:

 

Здесь consul_server представляет хост, на котором работает Consul Server. Точно так же мы можем запускать такие агенты на каждом из других узлов экземпляра MongoDB.

Примечание. Если у нас есть несколько экземпляров MongoDB, работающих на одном хосте, определение службы изменится, чтобы отразить разные порты, используемые каждым экземпляром для уникальной идентификации, обнаружения и мониторинга отдельного экземпляра MongoDB.

 

Consul на узлах, на которых запущено приложение Django

Для приложения Django настройка Consul будет очень простой. Нам нужно только отслеживать порт приложения Django, на котором Gunicorn прослушивает запросы.

Определение службы Consul будет выглядеть так:

 

Когда у нас есть определение службы Consul для приложения Django, мы можем запустить агента Consul, сидящего на узле, в котором приложение Django работает как служба. Чтобы запустить агента Consul, мы должны запустить следующую команду:

 

 

Consul Сервер

Мы запускаем кластер Consul с выделенным серверным узлом Consul. Узел сервера Consul может легко размещать, обнаруживать и отслеживать работающие на нем службы точно так же, как мы делали это в приведенных выше разделах для приложений MongoDB и Django.

Чтобы запустить Consul в режиме сервера и разрешить агентам подключаться к нему, мы запустим следующую команду на узле, на котором мы хотим запустить наш сервер Consul:

На данный момент на нашем узле сервера Consul нет служб, поэтому нет определений служб, связанных с этой конфигурацией агента Consul.

 

Fabio

Мы используем возможности Fabio для автоконфигурации и поддержки Consul.

Это очень упрощает нашу задачу по балансировке нагрузки трафика для наших экземпляров приложения Django.

Чтобы позволить Fabio автоматически определять службы через Consul, одним из способов является добавление тега или обновление тега в определении службы с помощью префикса и идентификатора службы `urlprefix- / <service>`. Определение службы нашего Consul для приложения Django теперь будет выглядеть так:

 

В нашем случае приложение или служба Django - единственная служба, которая нуждается в балансировке нагрузки, поэтому это изменение определения службы Consul выполняет требования по настройке Fabio.

 

Докеризация

Все наше приложение будет развернуто как набор контейнеров Docker. Давайте поговорим о том, как мы этого достигаем в контексте Consul.

 

Докеризация набора реплик MongoDB вместе с агентом Consul

Нам нужно запустить агент Consul, как описано выше, вместе с MongoDB в том же контейнере Docker, поэтому нам нужно будет запустить настраиваемый ENTRYPOINT в контейнере, чтобы разрешить запуск двух процессов.

Примечание. Этого также можно добиться с помощью проверок уровня контейнера Docker в Consul. Таким образом, вы сможете запустить агент Consul на хосте и проверить сервис, работающий в контейнере Docker. Что, по сути, будет запускаться в контейнер для мониторинга службы.

Для этого мы будем использовать инструмент, похожий на Foreman. Это инструмент управления жизненным циклом физических и виртуальных серверов, включая выделение ресурсов, мониторинг и настройку.

Чтобы быть точным, мы будем использовать Golang, заимствованный у Формана, Горемана. Он принимает конфигурацию в форме Procfile Heroku, чтобы понимать, какие процессы должны оставаться активными на хосте.

В нашем случае Procfile выглядит так:

 

«Consul_check» в конце профиля поддерживает динамизм между проверками как первичного, так и вторичного узла MongoDB в зависимости от того, за какую роль в наборе реплик MongoDB проголосовали.

Сценарии оболочки, которые выполняются соответствующими клавишами в файле Procfile, определены ранее в этом обсуждении.

Наш Dockerfile с некоторыми дополнительными инструментами для отладки и диагностики будет выглядеть так:

 

Примечание. Мы использовали здесь чистый образ Ubuntu 18.04 для наших целей, но вы можете использовать официальный образ MongoDB и адаптировать его для запуска Consul вместе с MongoDB или даже выполнять проверки Consul на уровне контейнера Docker, как указано в официальной документации.

 

Докеризация веб-приложения Django вместе с Consul Agent

Нам также необходимо запустить агент Consul вместе с нашим приложением Django в том же контейнере Docker, что и у нас с контейнером MongoDB.

Точно так же у нас будет Dockerfile для веб-приложения Django, как и для наших контейнеров MongoDB.

 

Докеризация Consul Server

Мы поддерживаем тот же поток с серверным узлом Consul, чтобы запустить его с пользовательским ENTRYPOINT. Это не является обязательным требованием, но мы поддерживаем единообразное представление различных файлов запуска Consul.

Кроме того, для демонстрации мы используем образ Ubuntu 18.04. Для этого вы можете использовать официальное изображение Consul, которое принимает все пользовательские параметры, указанные здесь.

 

Docker Compose

Мы используем Compose для запуска всех наших контейнеров Docker в желаемой, повторяемой форме.

Наш файл Compose написан для обозначения всех аспектов, о которых мы упомянули выше, и использует возможности инструмента Docker Compose для их беспрепятственного выполнения.

Файл Docker Compose будет выглядеть так, как показано ниже:

 

На этом мы подошли к концу настройки всей среды. Теперь мы можем запустить Docker Compose для сборки и запуска контейнеров.

 

Обнаружение услуг с использованием Consul

Когда все службы запущены и работают, пользовательский интерфейс Consul Web дает нам хороший обзор нашей общей настройки.

 

Сервис MongoDB доступен для приложения Django для обнаружения с помощью интерфейса Consul DNS.

 

Приложение Django теперь может подключить первичный экземпляр MongoDB и начать записывать в него данные.

Мы можем использовать балансировщик нагрузки Fabio для подключения к экземпляру приложения Django, автоматически обнаруживая его через реестр Consul с использованием специализированных сервисных тегов и отображая страницу со всей информацией о подключении к базе данных, о которой мы говорим.

Наш балансировщик нагрузки находится на «33 .10.0.100», а «/ web» настроен для перенаправления на один из наших экземпляров приложения Django, работающий за балансировщиком нагрузки.

 

Как вы можете видеть из автоматического определения и настройки балансировщика нагрузки Fabio из его пользовательского интерфейса выше, он одинаково взвешивал конечные точки веб-приложения Django. Это поможет сбалансировать нагрузку запроса или трафика на экземпляры приложения Django.

Когда мы посещаем наш URL-адрес Fabio «33 .10.0.100: 9999» и используем исходный маршрут как «/ web», мы перенаправляемся на один из экземпляров Django. Итак, посещение «33 .10.0.100: 9999 / web» дает нам следующий результат.

 

Веб-приложение Django отображает статус подключения MongoDB на домашней странице

Мы можем ограничить Fabio только экземплярами приложения Django с балансировкой нагрузки, добавив только необходимые теги в определения служб приложений Django в Consul.

Это обнаружение первичного экземпляра MongoDB помогает приложению Django выполнять миграцию базы данных и развертывание приложения.

Можно изучить веб-интерфейс Consul, чтобы увидеть все экземпляры служб веб-приложений Django.

 

Сервисы веб-приложений Django в веб-интерфейсе Consul

Точно так же посмотрите, как устроены экземпляры набора реплик MongoDB.

 

Давайте посмотрим, как Consul помогает с услугами проверки работоспособности и обнаружением только действующих служб.

Мы остановим текущий контейнер MongoDB Replica Set Primary (‘mongo_2’), чтобы посмотреть, что произойдет.

 

Consul перестал проходить проверку работоспособности для предыдущей основной службы MongoDB. Набор реплик MongoDB также обнаружил, что узел не работает и необходимо переизбрать основной узел. Таким образом, мы автоматически получаем новый MongoDB Primary («mongo_3»).

Наш переключатель проверок сработал и заменил проверку «mongo_3» со вторичной проверки MongoDB на первичную проверку MongoDB.

Когда мы смотрим на представление из приложения Django, мы видим, что теперь оно подключено к новой первичной службе MongoDB («mongo_3»).

 

Давайте посмотрим, как это разовьется, когда мы вернем остановленный экземпляр MongoDB.

 

Неисправный экземпляр первичной службы MongoDB теперь удален из экземпляров службы, так как теперь он является исправным экземпляром вторичной службы MongoDB.

Ранее отказавший экземпляр первичной службы MongoDB теперь повторно принят в качестве вторичного экземпляра службы MongoDB, поскольку он снова стал работоспособным

 

Точно так же, если мы остановим экземпляры службы приложения Django, Fabio теперь сможет обнаруживать только работоспособный экземпляр и направлять трафик только на этот экземпляр.

 

Fabio может автоматически настраиваться, используя реестр служб Consul и обнаруживая действующие экземпляры служб.

 

Вот как можно использовать возможность обнаружения служб Consul для обнаружения, мониторинга и проверки состояния служб.

 

Настройка сервиса с помощью Consul

В настоящее время мы настраиваем экземпляры приложения Django напрямую либо из переменных среды, установленных в контейнерах с помощью Docker Compose, и потребляем их в настройках проекта Django, либо путем жесткого кодирования параметров конфигурации напрямую.

Мы можем использовать хранилище ключей / значений Consul для обмена конфигурацией между обоими экземплярами приложения Django.

Мы можем использовать HTTP-интерфейс Consul для хранения пары ключ / значение и получения их в приложении, используя клиент Python с открытым исходным кодом для Consul, называемый python-consul. Вы также можете использовать любую другую библиотеку Python, которая может взаимодействовать с Consul KV, если хотите.

Давайте начнем с того, что посмотрим, как мы можем установить пару ключ / значение в Consul, используя его HTTP-интерфейс.

 

После того, как мы установили хранилище KV, мы можем использовать его в экземплярах приложения Django, чтобы настроить его с этими значениями.

Давайте установим python-consul и добавим его как зависимость проекта.

 

Нам нужно будет подключить наше приложение к Consul с помощью python-consul.

 

Мы можем захватить и настроить наше приложение Django соответствующим образом с помощью библиотеки «python-consul».

 

Эти пары ключ / значение из магазина Consul KV также можно просматривать и обновлять через его веб-интерфейс.

 

Consul KV store в интерфейсе Consul Web с параметрами конфигурации приложения Django

 

 

Код, используемый как часть этого руководства для раздела конфигурации службы Consul, доступен в ветви «service-configuration» проекта pranavcode / consul-demo.

Вот как можно использовать Consul KV и легко настраивать отдельные службы в их архитектуре.

 

Сегментация услуг с использованием Consul

В рамках сегментации услуг Consul мы рассмотрим намерения Consul Connect и распределение центров обработки данных.

Connect обеспечивает авторизацию и шифрование соединений между сервисами с использованием взаимного TLS.

Чтобы использовать Consul, вам необходимо включить его в конфигурации сервера. Для правильного функционирования кластера необходимо включить подключение в кластере Consul.

 

В нашем контексте мы можем определить, что связь должна быть идентифицирована и защищена TLS, мы определим восходящую сопутствующую службу с прокси в приложении Django для ее связи с первичным экземпляром MongoDB.

 

Наряду с настройкой Connect для бокового прокси нам также потребуется запустить прокси-сервер Connect для приложения Django. Этого можно добиться, выполнив следующую команду.

 

Мы можем добавить Consul Connect Intentions для создания графа сервисов для всех сервисов и определения шаблонов трафика. Мы можем создавать намерения, как показано ниже:

 

Намерениями для графа услуг также можно управлять из веб-интерфейса Consul.

 

Это определяет ограничения на подключение к службе, чтобы разрешить или запретить им общаться через Connect.

Мы также добавили возможность для агентов Consul указывать, к каким центрам обработки данных они принадлежат, и быть доступными через один или несколько серверов Consul в данном центре обработки данных.

Код, используемый как часть этого руководства для раздела сегментации услуг Consul, доступен в ветви «service-segmentation» проекта velotiotech / consul-demo.

Вот как можно использовать функцию сегментации услуг Consul и настроить контроль доступа к подключению на уровне обслуживания.

 

Вывод

Возможность беспрепятственно контролировать сервисную сеть, которую предоставляет Consul, очень упрощает жизнь оператора. Мы надеемся, что вы узнали, как Consul можно использовать для обнаружения, настройки и сегментации сервисов с его практической реализацией.

Как обычно, мы надеемся, что изучение Консула было познавательным. Это была последняя часть этой серии из двух частей. В этой части делается попытка охватить большинство аспектов архитектуры Consul и то, как она вписывается в ваш текущий проект. Если вы пропустили первую часть, вы сможете найти ее здесь.

Мы продолжим изучать различные технологии и предоставим вам наиболее ценную информацию. Сообщите нам, что вы хотели бы услышать от нас в следующий раз, или, если у вас есть какие-либо вопросы по этой теме, мы будем очень рады на них ответить.
