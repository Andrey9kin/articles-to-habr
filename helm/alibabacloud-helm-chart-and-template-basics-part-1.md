https://www.alibabacloud.com/blog/helm-chart-and-template-basics---part-1_595489

Основы работы с Helm чартами и темплейтами - Часть 1
В этом руководстве мы кратко обсудим, как Helm может помочь упростить управление приложениями Kubernetes, и узнаем, как использовать Helm для создания базового чарта.

Управление приложениями - сложный аспект Kubernetes. Helm значительно упрощает его, предоставляя единый метод упаковки программного обеспечения, поддерживающий контроль версий. Helm устанавливает пакеты (называются Чартами в Helm) для Kubernetes и управляет ими, как это делают yum и apt.
В этом руководстве мы позволим Helm создать для нас базовый чарт. В этом руководстве предполагается, что у вас есть хотя бы базовое понимание того, что такое Helm. Если вы не знакомы с ним, я предлагаю вам ознакомиться с этим руководством, прежде чем приступить к статье: https://www.alibabacloud.com/help/doc-detail/86511.htm
Затем мы будем постепенно вносить изменения, чтобы узнать, как файл значений и части шаблона работают вместе.
С таким базовым рабочим чартом легче работать, чем начинать с нуля.

https://docs.helm.sh/using_helm/
Чарт - это пакет Helm. Он содержит все определения ресурсов, необходимые для запуска приложения, инструмента или службы внутри кластера Kubernetes.

Создание полной структуры каталогов рабочего чарта
Это создает полный рабочий чарт со всеми необходимыми файлами в каталоге myhelm.

Вам будут представлены некоторые из этих файлов на протяжении всего этого руководства - только тогда, когда нам нужно узнать об этих конкретных файлах.
Цель - как можно скорее использовать чарт для создания работающего экземпляра. Затем мы исследуем, что создал чарт и как он это сделал.
Сначала идет файл values.yaml. Он содержит наши значения по умолчанию для объектов Kubernetes, которые мы хотим создать.
Вверху мы видим, что он использует nginx. Это загрузка весом 55 МБ. Я предпочитаю быстрые действия во время обучения с помощью busybox - загрузка 650 КБ.
Исходные значения .yaml

Измените values.yaml вверху, чтобы использовать busybox, как показано ниже. Обратите внимание на изменения тегов.

Далее идет файл deployment.yaml.
Это развертывание, как и любое другое, которое вы используете в Kubernetes. Основное отличие состоит в том, что большинство значений полей он получает из только что отредактированного файла значений.
Отредактируйте файл deployment.yaml около строки 27 ... добавьте команду. Мы используем образ busybox. Если мы создадим наши поды, они сразу же выйдут, так как ни одна команда или программа не запущены. Команда позволила нашему поду busybox спать 60 секунд.
(Вы можете увидеть в отрывке из шаблона ниже, как будут извлечены значения из values.yaml. Мы перейдем к синтаксису позже - пока мы сосредотачиваемся на общей картине.)

Теперь мы готовы позволить Helm установить наш отредактированный чарт.
Запустите helm install ./myhelm1/ и исследуйте вывод.

Helm автоматически генерирует название выпуска для вашего: NAME: loopy-otter
Ваш будет другим. Ненавижу эти глупые имена. Позже мы будем использовать наши собственные имена.
Мы видим сервис, развертывание и создание пода.
Грубо говоря, Helm прочитал все шаблоны .yaml в каталоге шаблонов, а затем интерпретировал эти шаблоны, извлекая значения из файла values.yaml.
Примечания относятся к исходному приложению nginx. Это совершенно неправильно для нашего приложения busybox.
Эти примечания взяты из NOTES.txt, другого файла шаблона.
Через несколько секунд мы увидим, что наш Pod работает.

Демонстрация общего обзора готова. Используйте helm delete, чтобы удалить наш первый выпуск.
https://docs.helm.sh/using_helm/
Релиз - это экземпляр чарта, работающей в кластере Kubernetes.

helmignore NOTES.txt
Теперь отредактируйте файл .helmignore и добавьте NOTES.txt внизу.
.helmignore содержит список имен файлов и шаблонов имен файлов, которые Helm должен игнорировать.

Если вы снова запустите установку, вы увидите, что эти примечания больше не отображаются. (Позже мы будем использовать такие заметки, но здесь и сейчас этот файл нам не нужен.)

Удалите наш тестовый выпуск 1.

--dry-run --debug
Мы используем --dry-run и --debug, чтобы исследовать, как Helm интерпретирует наш шаблон и файлы YAML в наших чартах.
Таким образом мы не засоряем наш узел Kubernetes несколькими ненужными объектами.
Давайте попробуем.

Как видите, релиз может существовать только один раз.
Проверить статус выпуска 

Мы просто удалили его.
Для тестирования отладки нам понадобится другое название выпуска: мы используем test2:

Очень полезно, но слишком много информации, если мы хотим постоянно редактировать и устанавливать наш чарт.
Прямо сейчас я не буду пытаться все это разобрать, давайте сначала уменьшим вывод.
Под Хуками есть тестовое соединение. Это было полезно для тестирования исходного nginx. Нам это не нужно.
Примерно через 20 строк мы находим # Source: myhelm1 / templates / service.yaml ... вид: Service - нам это не нужно - нам нужен только работающий Pod.
Его легко исправить, просто отредактируйте .helmignore и добавьте эти два имени файла внизу.

Нашему модулю busybox не нужны порты или датчики liveness.
Удалите строки с 29 по 42 из deployment.yaml

Эти ярлыки ниже не добавляют ценности этому руководству, поэтому они удаляются из вывода всех приведенных ниже команд установки helm.

Давайте переделаем нашу установку. 

Давайте разберемся  данных командах:
•	USER-SUPPLIED VALUES: мы их не предоставляли, поэтому здесь ничего не указано. Мы воспользуемся этим через минуту.
•	COMPUTED VALUES: показывает рассчитанные значения из values.yaml. Он отображается в алфавитном порядке, в то время как наш файл находится в случайном порядке.
•	HOOKS: не используются в этом рукоодстве для начинающих.
•	Внизу мы видим наш deployment.yaml. Он показывает шаблон со значениями, взятыми из файла values.yaml.
Вы можете неоднократно вносить изменения в свои значения и шаблоны и тестировать их с помощью --dry-run --debug. Он только показывает, что произойдет, не делая этого. Очень полезно: отладить установку Helm ДО того, как это будет сделано.
Мы довольны результатами отладки, давайте запустим установку.

Как и ожидалось - происходит развертывание и его Pod. Через несколько секунд Pod запускается.

imagePullPolicy = Never
Значения в values.yaml заменяют свои заполнители в файлах шаблонов.
Файлы шаблонов также могут получать свои значения от пользователя. Пользователи передают значения программному обеспечению, которое они устанавливают, с помощью флага --set в команде установки.
В этой части руководства демонстрируется передача imagePullPolicy в командной строке.
Редактирование не требуется, просто обратите внимание на последнюю строку извлечения файла значений ниже.
Файл значений по умолчанию должен называться values.yaml.

Теперь посмотрите, где он используется в шаблоне. (в диапазоне 22-25)

.Values.image.pullPolicy получает значение из
•	файла values.yaml ... .Values
•	содержимого .image.pullPolicy

До сих пор в этом руководстве мы использовали pullPolicy: IfNotPresent. (Возможно, вы захотите пролистать страницу и увидеть, что это так везде.)
Предположим, что для этого тестового прогона мы НЕ хотим, чтобы изображение было извлечено из репозитория. (imagePullPolicy: Never)
Из документации Kubernetes:
imagePullPolicy: Never: предполагается, что изображение существует локально. Попытки вытащить изображение не предпринимаются.

Смотрите приведенную ниже команду пробного запуска, как мы указываем политику с помощью --set.

USER-SUPPLIED VALUES кажутся правильными: imagePullPolicy: Never
COMPUTED VALUES: указывают на наличие проблемы:

Наша политика --set не заменяет политику изображений.
Они имеют разные имена и находятся на разных уровнях yaml.
В развертывании мы видим: imagePullPolicy: IfNotPresent: переопределение не выполнено.
Давайте исправим это: смотрите на вторую попытку:

Почти готово, но все равно неверно. Теперь у нас есть две политики, написанные по-разному. (Первая буква в нижнем регистре - это правильная буква, которая появляется в файле значений).
Соглашение гласит, что мы должны называть наши значения, начиная со строчной буквы. Наши values.yaml верны. Наше переопределение командной строки неверно.
Третья попытка, смотрите команду ниже.

В приведенном выше развертывании показано, как imagePullPolicy: Never ... прошло успешно.
COMPUTED VALUES показывают, что переопределение выполнено правильно.

Вывод отладки выглядит хорошо. Мы готовы установить этот выпуск вживую.
Я хочу скрыть все остальные валуи, которые нам не нужны. Отредактируйте файл значений так, чтобы только первые 5 значений не закомментировались.

Установим наш чарт

Values.ingress.enabled используется в myhelm1 / templates / ingress.yaml
Нам не нужен вход - это часть чарта nginx, с которого мы начали.
Добавьте ingress.yaml в конец нашего файла игнорирования.

Вторая попытка: установить чарт myhelm1 с помощью image.pullPolicy = Never
плюс мы добавили --set replicaCount = 3

--set replicaCount правильно переопределяет значение в deployment.yaml
Сделаем живую установку.

Успешно. ЖЕЛАТЕЛЬНОЕ развертывание - 3, и мы видим, что создаются 3 модуля.
Через несколько секунд у нас есть 3 работающих пода. Обратите внимание на использование команды helm status.

Демо завершено. Удалите наш релиз test3.

Определение нового value
Пока что мы удалили значения из values.yaml.
Мы также передали значения переопределения в командной строке.
Теперь мы создаем собственное новое значение: terminationGracePeriodSeconds

terminationGracePeriodSeconds
Необязательная продолжительность в секундах, необходимая для корректного завершения работы модуля. grace period - это продолжительность в секундах после того, как процессы, запущенные в модуле, отправляют сигнал завершения, и время, когда процессы принудительно останавливаются с сигналом уничтожения. Установите это значение больше, чем ожидаемое время очистки для вашего процесса. По умолчанию 30 секунд.

Добавьте terminationGracePeriodSeconds: 30 в свой файл значений, чтобы ваши строки 5–12 выглядели так, как показано ниже:

Отредактируйте файл развертывания, чтобы он использовал это новое значение (строки с 22 по 29 должны быть такими, как показано ниже)

Сделайте пробный запуск.

Успешно. COMPUTED VALUES: показывает их правильно и развертывание внизу использует их правильно.
Еще один тест: давайте отладим тест, переопределив значение terminationGracePeriodSeconds на 10.

Успешно. COMPUTED VALUES: правильно показывает 10 и при развертывании внизу правильно используется 10.
Мы даже не посмотрели на _helpers.tpl или каталог чартов. (Это касается зависимостей. Это тема для другого руководства из этого набора.)
Мы внесли несколько изменений в наш файл значений, а также в файл развертывания и увидели его результаты с помощью отладки и команд живой установки.
Вы также можете скрыть ненужные файлы с чарта. (.helmignore)
На работе вы создадите свои собственные скелетные базовые чарты, из которых будете копировать.
Мы изучили базовые концепции Helm в первый же день, изменив чарт nginx в соответствии с нашими требованиями. --dry-run --debug - лучшая функция Helm: пробный запуск и отладка перед установкой.
